---
author: おーせ
pubDatetime: 2024-03-25
title: LaravelにおけるDDD体験の備忘録
slug: laravel-clean-architecture
featured: true
draft: true
tags:
  - クリーンアーキテクチャ
  - Laravel
description:
  Laravel/Vueの実装においてDDDに則った実装を体験したので、その備忘録です。
---

## はじめに
今携わっている案件でLaravelにおけるクリーンアーキテクチャを勉強する必要があったので、その備忘録として学んだことを残します。

## なぜアーキテクチャが必要なのか
アーキテクチャについてかなりこだわる人が多く駆け出しの私はそれが不思議でした。<br />
しかし、今の受託案件では先方がどういったアーキテクチャを選定するかを求めてくることもあるとか、さすがになぜ必要かは認識しておかないとエンジニアとしてまずいと思いました。<br />
自分で調べた限り、クリーンアーキテクチャのメリットには共通して**可読性・保守性**といったワードが多かったです。<br />
責務の切り分けを一定のルールに乗っ取り行うことで**クラスやメソッド単位の役割が明確**になる。<br />
そういう積み重ねを丁寧にやっていけば、チームに誰かがジョインしたタイミングであっても、コードリーディングもしやすいため稼働が周りやすくなります。<br />
一昔前までは、今のものに比べるとハードウェアのCPUやメモリ数が低く、以下にメモリを使用せずCPUを浪費しないコードを書くかに重きがおかれていたようです。<br />
これは今でも気にすべきことですが、現在においてはアプリを長く運用するために**保守性が高く堅牢なアプリケーションに対して需要が高い**ため、クリーンアーキテクチャに対する知見が求められるのだと思います。

## アーキテクチャについて
アーキテクチャの名称云々は分かりませんが、以下4層の構成となっています。<br />
- Controller
- Usecase
- Service
- Repository
各層の役割についてそれぞれまとめていきます。
### Repository層
外部APIやORMによるDB操作などをRepository層で行なっています。<br />
複雑なロジックは書かないことを心がけ、何をする実装かを明確にした上で実装しました。<br />
例えば、TaskといったモデルのRepository層でuseIdにひもづくレコードを取得する実装は以下のようになります。<br />

```php
// クラスやuseは省略しています

public function fetchTask(): Task
{
    return  
}

```
また、Taskモデルの1レコードを削除する実装は以下のようになります。
```php

```
実務の中で以下の2点を注意されました。<br />
- 返り値voidは極力避けること
- 誰がみてもわかる名称にすること
それぞれ振り返っていけたらと思います。

#### 返り値voidは極力避ける
何かを作成したりするメソッドでも必要な場面が想定される場合は可能な限り返り値を指定することを指摘されました。<br />
これには大きく2つの意味があると思います。
- **汎用性高いメソッド**にするため
実装するメソッドはRepository層であれば他の開発者も使う可能性があります。<br />
実装者の使用場面では`void`であっても他の実装者は返り値を求める可能性があります。<br />
後から実装しても良いですが、極力実装するタイミングである程度汎用的なメソッドにするために想定しうる返り値を指定することが大事なのかな、と理解しました。

- テストが書きやすくなる
これは指摘していただいた方がおっしゃっていていたのですが、単体テストが書きやすくなるとのことでした。<br />
書きやすくなるというか、返り値まで想定してテストすることで**より堅牢なテスト設計が可能になる**という意味だと思います。<br />
テストが落ちなければ基本バグはでない、保守性の高いアプリを作るためにはテスト設計まで頭に入れる必要があるな、と思いました。<br />

#### 誰が見てもわかる名称にすること
例えば`Task`というモデルを取得するメソッドを実装する際に私は当初以下のような実装をしました。<br />

```php
public function fetchTask(int $userId): Task
{
   // userIdに紐づくTaskを1レコード取得する処理を実装 
}

```
上の実装対して、「*fetchTaskByUserIdとかにしましょう。主キーによる取得と勘違いする可能性があります*」とレビューいただきました。<br />
こういったメソッド名を見て実装内容を判断できるのと、実装内容を見ないと理解できないのではコードリーディングの負担も変わります。<br />
一つ一つの命名規則も他の開発者の負担を考慮しなくては、と思いました。<br />
### Service層
サービス層は**ドメインロジック**を記述してほしい、とリードエンジニアの方から言われました。<br />
一方でUsecase層では**アプリケーションロジック**を記述してほしい、とのこと。<br />
それぞれどう違うのかがよくわからなかったので、調べてみました。
#### ドメインロジック
そもそもドメインとは、アプリケーションで扱うビジネス上の問題領域や範囲を指すようです。<br />
例えば、オンラインショップサービスのアプリケーションを例にとると、ドメインは商品、注文、顧客、支払いなどの要素で構成されます。<br />
商品という要素のドメインに関するロジックでは以下のような例が挙げられます。
- **在庫管理**
  商品の在庫数を追跡し、注文があった場合に在庫数を更新するなど<br />
- **価格設定**
  セールやキャンペーンなどの特別な価格設定や、数量割引、顧客ごとの割引などを管理するロジックなど<br />
- **商品カテゴリ**
  商品を適切なカテゴリーに分類方法<br />
- **配送と在庫の連携**
  注文が発生した場合、在庫を減らし、配送の準備を行うロジック<br />

つまり、Service層では上記の例のようなロジックをコードで表現する場所として考えて良さそうです。<br />
棲み分けはアプリケーションロジックを調べてから考えようかと思います。<br />
#### アプリケーションロジック
これはアプリがが実行する具体的な機能や手続きを指します。<br />
ドメインロジックを含むソフトウェア全体のロジックの一部ですが、ドメインロジックとは異なる側面があります。<br />
以下のようなロジックが例として挙げられます。<br />

- **ユーザー認証と認可**
  ユーザーがアプリケーションにログインする際の認証や、そのユーザーがどの機能やリソースにアクセスできるかを決定する認可ロジックなど<br />
- **エラーハンドリングや例外処理**
  アプリケーションがエラー状態になった場合の処理や、予期しない状況に対する例外処理<br />

特定の機能や操作に焦点を当てていますが、ドメインロジックはビジネスドメイン全体をカバーし、ビジネスルールやプロセスに関連するロジックを扱うようです。<br />


### Usecase層


### Controller層
フロントからRequestを受け取りUsecaseに渡した結果の返り値をViewに返すという処理に終始しています。<br />
受け取って返すという処理に留めておくことを心がけていますが、viewに返す変数の整形は行なっています。<br />
本来これは`ViewModel`を使って整形すべきかもしれませんが、実装上の負担と天秤にかけつつ複雑な処理にならなければ、コントローラで実装しています。
